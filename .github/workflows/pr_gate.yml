name: pr-gate
on:
  pull_request:
defaults:
  run:
    working-directory: workflow-cookbook
jobs:
  gate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Require CODEOWNERS approval
        id: codeowners
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const blockers = [];
            const failWith = (message) => {
              blockers.push(message);
              core.setOutput('blockers', JSON.stringify(blockers));
              core.setOutput('hasApproval', 'false');
              core.setFailed(message);
            };
            const toRegex = (pattern) => {
              let normalized = pattern.trim();
              if (!normalized) return null;
              if (normalized.startsWith('/')) normalized = normalized.replace(/^\/+/, '');
              if (normalized.endsWith('/')) normalized = `${normalized}**`;
              if (normalized === '*') return /^.*$/;
              const escaped = normalized
                .replace(/([\\^$+?.()|{}\[\]])/g, '\\$1')
                .replace(/\\\*\\\*/g, '.*')
                .replace(/\\\*/g, '.*')
                .replace(/\\\?/g, '.');
              return new RegExp(`^${escaped}$`);
            };
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const codeownersRelativePath = '.github/CODEOWNERS';
            const codeownersPath = path.join(workspace, codeownersRelativePath);
            let codeownersContent;
            try {
              codeownersContent = fs.readFileSync(codeownersPath, 'utf8');
            } catch (error) {
              const reason = error instanceof Error ? error.message : String(error);
              failWith(`Unable to read CODEOWNERS at ${codeownersPath}: ${reason}`);
              return;
            }
            const entries = [];
            for (const rawLine of codeownersContent.split(/\r?\n/)) {
              const line = rawLine.trim();
              if (!line || line.startsWith('#')) continue;
              const [pattern, ...owners] = line.split(/\s+/);
              if (!pattern || owners.length === 0) continue;
              const regex = toRegex(pattern);
              if (regex) entries.push({owners, regex});
            }
            if (entries.length === 0) {
              failWith('No CODEOWNERS entries could be parsed.');
              return;
            }
            const {owner, repo} = context.repo;
            const pr = context.payload.pull_request || {};
            const requestedUsers = new Set(
              (Array.isArray(pr.requested_reviewers) ? pr.requested_reviewers : [])
                .map((reviewer) => (reviewer && reviewer.login ? `@${reviewer.login}` : null))
                .filter((login) => typeof login === 'string'),
            );
            const requestedTeams = new Set(
              (Array.isArray(pr.requested_teams) ? pr.requested_teams : [])
                .map((team) => {
                  if (!team) return null;
                  const slug = team.slug || team.name;
                  if (!slug) return null;
                  const org = (team.organization && team.organization.login) || owner;
                  return `@${org}/${slug}`;
                })
                .filter((team) => typeof team === 'string'),
            );
            const pull_number = context.payload.pull_request.number;
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {owner, repo, pull_number, per_page: 100},
            );
            const codeownerUsers = new Set();
            const codeownerTeams = new Set();
            const uncovered = [];
            for (const file of files) {
              const owners = entries.reduce(
                (matched, entry) => (entry.regex.test(file.filename) ? entry.owners : matched),
                [],
              );
              if (owners.length === 0) {
                uncovered.push(file.filename);
                continue;
              }
              for (const ownerHandle of owners) {
                if (!ownerHandle.startsWith('@')) continue;
                if (ownerHandle.includes('/')) codeownerTeams.add(ownerHandle);
                else codeownerUsers.add(ownerHandle);
              }
            }
            const filteredRequestedUsers = Array.from(requestedUsers).filter((login) =>
              codeownerUsers.has(login),
            );
            const filteredRequestedTeams = Array.from(requestedTeams).filter((team) =>
              codeownerTeams.has(team),
            );
            if (uncovered.length > 0) {
              failWith(`No CODEOWNERS match for: ${uncovered.join(', ')}`);
              return;
            }
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              {owner, repo, pull_number, per_page: 100},
            );
            const latestStates = new Map();
            for (const review of reviews) {
              const login = review.user?.login;
              const state = review.state?.toUpperCase();
              if (!login || !state) continue;
              latestStates.set(`@${login}`, state);
            }
            const approvals = new Set();
            const allChangeRequesters = Array.from(latestStates.entries())
              .filter(([, state]) => state === 'CHANGES_REQUESTED')
              .map(([login]) => login);
            for (const [login, state] of latestStates.entries()) {
              if (state === 'APPROVED') approvals.add(login);
            }
            if (allChangeRequesters.length > 0) {
              failWith(`Changes requested by: ${allChangeRequesters.join(', ')}`);
              return;
            }
            const requiredUsers = Array.from(new Set([...codeownerUsers, ...filteredRequestedUsers]));
            const pendingApprovals = requiredUsers.filter((login) => !approvals.has(login));
            if (pendingApprovals.length > 0) {
              const messages = pendingApprovals.map((login) => `${login} (awaiting approval)`);
              failWith(`Awaiting required review from: ${messages.join(', ')}`);
              return;
            }
            const pendingTeams = filteredRequestedTeams;
            if (pendingTeams.length > 0) {
              const teamMessages = pendingTeams.map((team) => `${team} (team review required)`);
              failWith(`Awaiting required review from: ${teamMessages.join(', ')}`);
              return;
            }
            if (requiredUsers.length === 0 && approvals.size === 0) {
              failWith('Awaiting CODEOWNERS approval: no approvals recorded yet.');
              return;
            }
            core.setOutput('blockers', JSON.stringify(blockers));
            core.setOutput('hasApproval', 'true');
            core.notice('All CODEOWNERS reviews have approved and no changes are requested.');
      - name: Enforce governance gate
        run: python tools/ci/check_governance_gate.py
      - name: Block auto-merge (informational)
        run: |
          echo "Auto merge is disabled by policy"
          exit 0
      - name: Fail pending CODEOWNERS approval
        if: ${{ steps.codeowners.outcome == 'failure' }}
        run: |
          echo "CODEOWNERS approval pending; marking job as failed"
          exit 1
