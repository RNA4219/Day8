name: pr-gate
on:
  pull_request:

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true
defaults:
  run:
    working-directory: workflow-cookbook
jobs:
  gate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Governance gate (soft)
        id: governance_gate
        run: python tools/ci/check_governance_gate.py
        continue-on-error: true
      - name: Governance gate failure enforcement
        if: ${{ steps.governance_gate.outcome == 'failure' }}
        run: exit 1
      - name: Require CODEOWNERS approval
        id: codeowners
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const toHandle = (ownerHandle) => {
              if (!ownerHandle.startsWith('@')) return `@${ownerHandle}`;
              return ownerHandle;
            };
            const toTeamHandle = (team, defaultOrg) => {
              if (!team) return null;
              const slug = team.slug || team.name;
              const org = (team.organization && team.organization.login) || defaultOrg;
              if (!slug || !org) return null;
              return `@${org}/${slug}`;
            };
            const blockers = [];
            core.setOutput('hasTeamCoverage', 'false');
            const failWith = (message) => {
              blockers.push(message);
              core.setOutput('blockers', JSON.stringify(blockers));
              core.setOutput('hasApproval', 'false');
              core.setFailed(message);
            };
            const toRegex = (pattern) => {
              let normalized = pattern.trim();
              if (!normalized) return null;
              if (normalized.startsWith('/')) normalized = normalized.replace(/^\/+/, '');
              if (normalized.endsWith('/')) normalized = `${normalized}**`;
              if (normalized === '*') return /^.*$/;
              const escaped = normalized
                .replace(/([\\^$+?.()|{}\[\]])/g, '\\$1')
                .replace(/\\\*\\\*/g, '.*')
                .replace(/\\\*/g, '.*')
                .replace(/\\\?/g, '.');
              return new RegExp(`^${escaped}$`);
            };
            const parseCodeowners = (content) => {
              const entries = [];
              for (const rawLine of content.split(/\r?\n/)) {
                const line = rawLine.trim();
                if (!line || line.startsWith('#')) continue;
                const [pattern, ...owners] = line.split(/\s+/);
                if (!pattern || owners.length === 0) continue;
                const regex = toRegex(pattern);
                if (!regex) continue;
                entries.push({owners, regex});
              }
              return entries;
            };
            const collectCodeownersForFiles = (entries, files) => {
              const codeownerUsers = new Set();
              const codeownerTeams = new Set();
              const uncovered = [];
              const findOwnersForFile = (filePath) => {
                let owners = [];
                for (const entry of entries) {
                  if (entry.regex.test(filePath)) {
                    owners = entry.owners;
                  }
                }
                return owners;
              };
              for (const file of files) {
                const owners = findOwnersForFile(file.filename);
                if (owners.length === 0) {
                  uncovered.push(file.filename);
                  continue;
                }
                for (const ownerHandle of owners) {
                  const normalized = toHandle(ownerHandle);
                  if (normalized.includes('/')) codeownerTeams.add(normalized);
                  else codeownerUsers.add(normalized);
                }
              }
              return {codeownerUsers, codeownerTeams, uncovered};
            };
            const toTeamSlugParts = (teamHandle) => {
              if (typeof teamHandle !== 'string') return null;
              const trimmed = teamHandle.trim();
              if (!trimmed) return null;
              const normalized = trimmed.startsWith('@') ? trimmed.slice(1) : trimmed;
              const [org, slug] = normalized.split('/');
              if (!org || !slug) return null;
              return {org, team_slug: slug};
            };
            const teamMembersCache = new Map();
            const fetchTeamMembers = async (teamHandle) => {
              const slugParts = toTeamSlugParts(teamHandle);
              if (!slugParts) return null;
              if (teamMembersCache.has(teamHandle)) return teamMembersCache.get(teamHandle);
              try {
                const members = await github.paginate(
                  github.rest.teams.listMembersInOrg,
                  {...slugParts, per_page: 100},
                );
                const handles = new Set(
                  members
                    .map((member) => (member && member.login ? `@${member.login}` : null))
                    .filter((handle) => typeof handle === 'string'),
                );
                teamMembersCache.set(teamHandle, handles);
                return handles;
              } catch (error) {
                const reason = error instanceof Error ? error.message : String(error);
                core.warning(`Unable to fetch members for ${teamHandle}: ${reason}`);
                teamMembersCache.set(teamHandle, null);
                return null;
              }
            };
            const workspace = process.env.GITHUB_WORKSPACE || process.cwd();
            const codeownersRelativePath = '.github/CODEOWNERS';
            const codeownersPath = path.join(workspace, codeownersRelativePath);
            let codeownersContent;
            try {
              codeownersContent = fs.readFileSync(codeownersPath, 'utf8');
            } catch (error) {
              const reason = error instanceof Error ? error.message : String(error);
              failWith(`Unable to read CODEOWNERS at ${codeownersPath}: ${reason}`);
              return;
            }
            const entries = parseCodeowners(codeownersContent);
            if (entries.length === 0) {
              failWith('No CODEOWNERS entries could be parsed.');
              return;
            }
            const {owner, repo} = context.repo;
            const pr = context.payload.pull_request || {};
            const requestedUserHandles = new Set(
              (Array.isArray(pr.requested_reviewers) ? pr.requested_reviewers : [])
                .map((reviewer) => (reviewer && reviewer.login ? `@${reviewer.login}` : null))
                .filter((login) => typeof login === 'string'),
            );
            const requestedTeamHandles = new Set(
              (Array.isArray(pr.requested_teams) ? pr.requested_teams : [])
                .map((team) => toTeamHandle(team, owner))
                .filter((team) => typeof team === 'string'),
            );
            const pull_number = context.payload.pull_request.number;
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              {owner, repo, pull_number, per_page: 100},
            );
            const codeownerUsers = new Set();
            const codeownerTeams = new Set();
            const uncovered = [];
            let hasBlockingOwners = false;
            for (const file of files) {
              const owners = entries.reduce(
                (matched, entry) => (entry.regex.test(file.filename) ? entry.owners : matched),
                [],
              );
              if (owners.length === 0) {
                uncovered.push(file.filename);
                continue;
              }
              for (const ownerHandle of owners) {
                if (!ownerHandle.startsWith('@')) continue;
                hasBlockingOwners = true;
                if (ownerHandle.includes('/')) codeownerTeams.add(ownerHandle);
                else codeownerUsers.add(ownerHandle);
              }
            }
            if (!hasBlockingOwners) {
              core.setOutput('blockers', JSON.stringify(blockers));
              core.setOutput('hasApproval', 'true');
              core.notice('CODEOWNERS contains no GitHub handles; skipping approval enforcement.');
              return;
            }
            const requestedUsers = Array.from(requestedUserHandles);
            const requestedTeams = Array.from(requestedTeamHandles);
            const filteredRequestedUsers = requestedUsers.filter((login) =>
              codeownerUsers.has(login),
            );
            const filteredRequestedTeams = requestedTeams.filter((team) =>
              codeownerTeams.has(team),
            );
            if (uncovered.length > 0) {
              failWith(`No CODEOWNERS match for: ${uncovered.join(', ')}`);
              return;
            }
            if (filteredRequestedUsers.length > 0 || filteredRequestedTeams.length > 0) {
              const pending = [
                ...filteredRequestedUsers.map((login) => `${login} (review requested)`),
                ...filteredRequestedTeams.map((team) => `${team} (team review requested)`),
              ];
              failWith(`Awaiting required review from: ${pending.join(', ')}`);
              return;
            }
            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              {owner, repo, pull_number, per_page: 100},
            );
            const latestStates = new Map();
            const teamReviewStates = new Map();
            const requiredHandles = new Set(codeownerUsers);
            const collaboratorApprovals = new Set();
            const collaboratorChangeRequesters = new Set();
            const collaboratorAssociations = new Set(['MEMBER', 'OWNER', 'COLLABORATOR']);
            for (const review of reviews) {
              const login = review.user?.login;
              const state = review.state?.toUpperCase();
              if (!login || !state) continue;
              const loginHandle = `@${login}`;
              if (requiredHandles.has(loginHandle)) {
                latestStates.set(loginHandle, state);
              }
              const association = typeof review.author_association === 'string'
                ? review.author_association.toUpperCase()
                : '';
              if (!collaboratorAssociations.has(association)) continue;
              if (state === 'APPROVED') collaboratorApprovals.add(loginHandle);
              if (state === 'CHANGES_REQUESTED') collaboratorChangeRequesters.add(loginHandle);
              const teamHandle = toTeamHandle(review.team, owner);
              if (teamHandle) {
                teamReviewStates.set(teamHandle, state);
              }
            }
            const approvals = new Set();
            const allChangeRequesters = new Set(
              Array.from(latestStates.entries())
                .filter(([, state]) => state === 'CHANGES_REQUESTED')
                .map(([login]) => login),
            );
            for (const [login, state] of latestStates.entries()) {
              if (state === 'APPROVED') approvals.add(login);
            }
            for (const handle of collaboratorChangeRequesters) {
              allChangeRequesters.add(handle);
            }
            if (allChangeRequesters.size > 0) {
              failWith(`Changes requested by: ${Array.from(allChangeRequesters).join(', ')}`);
              return;
            }
            const requiredUsers = Array.from(new Set([...codeownerUsers, ...filteredRequestedUsers]));
            const pendingApprovals = requiredUsers.filter((login) => !approvals.has(login));
            if (pendingApprovals.length > 0) {
              const messages = pendingApprovals.map((login) => `${login} (awaiting approval)`);
              failWith(`Awaiting required review from: ${messages.join(', ')}`);
              return;
            }
            const teamHandles = Array.from(codeownerTeams);
            const pendingTeamHandles = [];
            for (const team of teamHandles) {
              const reviewState = teamReviewStates.get(team);
              if (reviewState === 'APPROVED') {
                continue;
              }
              const members = await fetchTeamMembers(team);
              let hasMemberApproval = false;
              if (members && members.size > 0) {
                for (const handle of collaboratorApprovals) {
                  if (members.has(handle)) {
                    hasMemberApproval = true;
                    break;
                  }
                }
              }
              if (hasMemberApproval) {
                continue;
              }
              pendingTeamHandles.push(team);
            }
            const hasTeamCoverage = teamHandles.length > 0 && pendingTeamHandles.length === 0;
            core.setOutput('hasTeamCoverage', hasTeamCoverage ? 'true' : 'false');
            if (pendingTeamHandles.length > 0) {
              const teamMessages = pendingTeamHandles.map((team) => `${team} (team review required)`);
              failWith(`Awaiting required review from: ${teamMessages.join(', ')}`);
              return;
            }
            if (hasBlockingOwners && requiredUsers.length === 0 && approvals.size === 0) {
              if (!hasTeamCoverage) {
                failWith('Awaiting CODEOWNERS approval: no approvals recorded yet.');
                return;
              }
              core.notice('CODEOWNERS team coverage satisfied without individual approvals.');
            }
            core.setOutput('blockers', JSON.stringify(blockers));
            core.setOutput('hasApproval', 'true');
            core.notice('All CODEOWNERS reviews have approved and no changes are requested.');
      - name: Block auto-merge (informational)
        run: |
          echo "Auto merge is disabled by policy"
          exit 0
      - name: Fail pending CODEOWNERS approval
        if: ${{ steps.codeowners.outputs.hasApproval != 'true' }}
        run: |
          echo "CODEOWNERS approval pending; marking job as failed"
          exit 1
