name: pr-gate
on:
  pull_request:
defaults:
  run:
    working-directory: workflow-cookbook
jobs:
  gate:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
      - name: Require CODEOWNERS approval
        id: codeowners
        continue-on-error: true
        uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo} = context.repo;
            const pull_number = context.payload.pull_request.number;
            const {data: pr} = await github.rest.pulls.get({
              owner,
              repo,
              pull_number,
            });

            const codeownerUsers = new Set(
              (pr.requested_reviewers ?? []).map((reviewer) => `@${reviewer.login}`),
            );
            const codeownerTeams = new Set(
              (pr.requested_teams ?? []).map(
                (team) => `@${team.organization.login}/${team.slug}`,
              ),
            );

            const reviews = await github.paginate(
              github.rest.pulls.listReviews,
              {
                owner,
                repo,
                pull_number,
                per_page: 100,
              },
            );

            const latestStates = new Map();
            for (const review of reviews) {
              const login = review.user?.login;
              const state = review.state?.toUpperCase();
              if (!login || !state) {
                continue;
              }
              latestStates.set(`@${login}`, state);
            }

            const approvals = new Set();
            const allChangeRequesters = Array.from(latestStates.entries())
              .filter(([, state]) => state === 'CHANGES_REQUESTED')
              .map(([login]) => login);
            for (const [login, state] of latestStates.entries()) {
              if (state === 'APPROVED') {
                approvals.add(login);
              }
            }

            if (allChangeRequesters.length > 0) {
              core.setFailed(`Changes requested by: ${allChangeRequesters.join(', ')}`);
              return;
            }

            const requiredUsers = Array.from(codeownerUsers);
            const pendingApprovals = requiredUsers.filter((login) => !approvals.has(login));
            if (pendingApprovals.length > 0) {
              const messages = pendingApprovals.map((login) => `${login} (awaiting approval)`);
              core.setFailed(`Awaiting required review from: ${messages.join(', ')}`);
              return;
            }

            if (codeownerTeams.size > 0) {
              const teamMessages = Array.from(codeownerTeams).map(
                (team) => `${team} (team review required)`,
              );
              core.setFailed(`Awaiting required review from: ${teamMessages.join(', ')}`);
              return;
            }

            if (requiredUsers.length === 0 && approvals.size === 0) {
              core.setFailed('Awaiting CODEOWNERS approval: no approvals recorded yet.');
              return;
            }

            core.notice('All CODEOWNERS reviews have approved and no changes are requested.');
      - name: Enforce governance gate
        run: python tools/ci/check_governance_gate.py
      - name: Block auto-merge (informational)
        run: |
          echo "Auto merge is disabled by policy"
          exit 0
      - name: Fail pending CODEOWNERS approval
        if: ${{ steps.codeowners.outcome == 'failure' }}
        run: |
          echo "CODEOWNERS approval pending; marking job as failed"
          exit 1
